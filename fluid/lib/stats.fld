let split [] = ([], []);
    split (x : xs) =
      let (ys, zs) = split xs in (x : zs, ys);

let merge xs ys =
       match (xs, ys) as {
          ([], _) -> ys;
          (x : xs', []) -> xs;
          (x : xs', y : ys') ->
             if x < y
             then x : merge xs' ys
             else y : merge xs ys'
       };

let mergesort xs =
       if length xs < 2
       then xs
       else
          let (ys, zs) = split xs in
          merge (mergesort ys) (mergesort zs);

-- assume xs is sorted
let findQuantile q p xs =
    let rank = (p / q) * (length xs - 1)
    in if rank == floor rank
    then nth rank xs
    else let x1 = floor rank;
             x2 = ceiling rank;
             left = nth x1 xs;
             right = nth x2 xs
        in left + (rank - x1) * (right - left);

let findPercentile = findQuantile 100;

let accumBins data Nil = [];
    accumBins data [l] = [];
    accumBins data (l : r : es) =
        let (ge, le) = splitOn (fun x -> x <= r) data
        in (le, r - l) : accumBins ge (r : es);

let cut xs nbins =
    let low = minimum xs;
        binwidth = (maximum xs - low) / nbins;
        edges = [ low + (x * binwidth) | x <- enumFromTo 0 nbins ]
    in accumBins xs edges;

let qcut xs qs =
    let (low, high) = (minimum xs, maximum xs);
        edges = append (low : [ findPercentile x xs | x <- qs], [high])
    in accumBins xs edges;

let likelihoodLE xs target =
    length (filter (fun x -> x <= target) xs) / length xs;

let likelihoodGE xs target =
    length (filter (fun x -> x >= target) xs) / length xs;

let likelihoodMap table prob = (fromSome (find (fun x -> x.prob <= prob) table)).msg;

let mkPercent num = numToStr (num * 100) ++ "%";

let leqP n m =
    if n <= m
    then "less"
    else "more";

let gradedLeqP n m =
    let ratio = n / m
    in if ratio <= 1.0
        then if ratio <=0.5
            then "much less"
            else "less"
        else if ratio >= 2.0
            then "much more"
            else "more";
