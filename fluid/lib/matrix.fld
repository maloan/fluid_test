let zero m n image =
    let (m_max, n_max) = dims image
    in if (m >= 1) `and` (m <= m_max) `and` (n >= 1) `and` (n <= n_max)
    then image!(m, n)
    else 0;

let wrap m n image =
    let (m_max, n_max) = dims image
    in image!( ((m - 1) `mod` m_max) + 1, ((n - 1) `mod` n_max) + 1);

let extend m n image =
    let (m_max, n_max) = dims image;
        m' = min (max m 1) m_max;
        n' = min (max n 1) n_max
    in image!(m', n');

let matrixSum matr =
    let (m, n) = dims matr
    in foldl (+) 0 [ matr!(i, j) | (i, j) <- range (1, 1) (m, n)];

let convolve image kernel lookup =
    let ((m, n), (i, j)) = (dims image, dims kernel);
        (half_i, half_j) = (i `quot` 2, j `quot` 2);
        area = i * j
    in [| let interMatrix =
              """Intermediate matrix for element (${m'}, ${n'})"""
              [| let x = m' + i' - 1 - half_i;
                     y = n' + j' - 1 - half_j in
                lookup x y image * kernel!(i', j')
              | (i', j') in (i, j) |]
          in matrixSum interMatrix `quot` area
          | (m', n') in (m, n) |];

let matMul a b =
    let ((m, n), (i, j)) = (dims a, dims b) in
    if not (n == i)
    then error "Dimension mismatch"
    else [| sum [ a!(i', k) * b!(k, j') | k <- enumFromTo 1 n]
          | (i', j') in (m, j) |];
